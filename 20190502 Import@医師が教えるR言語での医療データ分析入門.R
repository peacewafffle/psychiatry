###########################################################
#####セクション3 インポート##########################
###########################################################

###########################################################
#レクチャー： パスとディレクトリのRでの実践--------------------
###########################################################

# RStudioでのワーキングディレクトリはどこにある？

#結論から言うと、.Rproj　ファイルがある場所です。

#プロジェクトを開いた時の、
#右下のFiles画面がワーキングディレクトリです。

#コマンドでは、
getwd()

#で、ディレクトリのパスが表示されます。
#ちょっと、More -> Show folder in new windowを
#クリックしてみましょう。

#「ichiji」という名前のフォルダを作成して、その中に、
#「tekitou.txt」という名前のファイルを作ります。
# そして、そのファイルの中に、
#好きな文字を記入してみましょう。(英語で・・・)

#そのファイルのフルパスをread_file()関数に入れて
#実行しましょう。
#read_fileは、readrパッケージに含まれるので、
#readr::read_file() とかくか、
#library(readr)を先に実行して、
#パッケージをロードしておきましょう。

readr::read_file(
  "D:/new/import/new/ichiji/tekitou.txt"
  )

#初めてのインポート成功です！

#今度は日本語を書いてみて下さい。

library(readr)
read_file(
  "D:/new/import/new/ichiji/tekitou.txt"
  )
￥
#文字化けしていますね。
#Macで実行している場合には生じない可能性があるので、
#問題ない人は飛ばして下さい。

#Rでは、基本的にUTF-8という文字コードを利用しています。
#文字コードは、パソコンにしかわからない暗号を、
#人が読める文字に変換するための変換表です。

#Windowsは、Shift-Jisという文字コードを利用しているため、
#Shift-Jisの日本語で記載された文字コードを、
#UTF-8で読み込むと、文字化けするのです。

#この現象を回避するには
#読み込む時に、文字コードを指定してあげます。

#locale = locale(encoding = "shift_jis)

#というオプションをreadrにつけてあげましょう。
library(readr)
read_file(
  "D:/new/import/new/ichiji/tekitou.txt", 
  locale = locale(encoding = "shift_jis")
  )

#よめました！

#まとめ

#・ワーキングディレクトリの確認には、getwd()を使おう！
#・ファイルの読み込みにはreadrパッケージを利用して
#　　read_fileで読み込もう
#・日本語で文字化けする場合は、
#　　文字コードを指定して読み込んでみよう

###########################################################
#レクチャー： read_delim関数のRでの実践--------------------
###########################################################

#本レクチャーからダウンロードできるファイルをダウンロードして
#実際にインポートできるか試みてみてください。

# ファイルは
# 　import_practice.txt
#   import_practice2.txt
#   import_practice3.txt
#   
#   の3種類です。拡張子はヒントにならないようにあえて、外してあります。

#次はヒントです。もし自力で試したい方は飛ばしてください。

#どこに保存したらよい？
getwd()
#がパスのレクチャーでお話しした、「妖精？」がいる場所です。

#デリミターは何を設定したら良い？
#ファイルをメモ帳等のテキストエディタで開いて
#じっくりみたら、わかるはずです。

#=========================================
read_file("import_practice.txt")

#\tはTABを表す文字列です。ですので、これはタブ区切り
#delim = "\t"と入力することで読み込むことができます。

library(readr)
read_delim("import_practice.txt", delim = "\t")

#もしくは、delim="\t"がデフォルトの設定となっている
#read_delim　→　read_tsvを利用します
read_tsv("import_practice.txt")

#========================
# 次のファイルは、
read_file("import_practice2.txt")

# "\r\n"は改行を表します。
# ちょっとRで確認するのはしんどいですが、
#「,」で区切られているみたいです

read_delim("import_practice2.txt",delim=",")

read_csv("import_practice2.txt")

#===================================
#最後は、
read_file("import_practice3.txt")

read_delim("import_practice3.txt", delim=";")

read_csv2("import_practice3.txt")

#どうですか？すべてインポートできましたか？
#次のレクチャーではParseについて説明します。

###########################################################
#レクチャー： ParseのRでの実践-------------------------------
###########################################################

#parseとは、プログラミング言語であつかえる形に
#データを変換するという意味がある英単語です。
 parse_number(c("a",1,2,3))

 parse_character(c("a","b","c",1,2,3))

#ベクトルは基本的には同じ型である必要がありました
 c(1,2,3,"a")

#parse_**は、読み込んだ列に対して、
#型変換を行う関数です。
 
#通常、read_***関数が自動で処理をしてくれるので、
#意識しなくてもよいですが、自動処理に頼り切っていると
#落とし穴があります。
 
#ここでは、例として、import_practice2.txt
#(,で区切られているファイル。)
#を読み込んでみましょう。

###########################################################
#レクチャー： importとparseの落とし穴1&2---------------------
###########################################################


#読み込んだデータは適当な変数名(DT)に放り込んでおきます。
 
DT <- read_csv("import_practice2.txt")


#色々と警告のメッセージが出ていますが、ここでは無視。

DT

#実行すると最初の10行をみることができます。
#read_delim（read_csv, read_tsv, read_csv2 等)で読み込むと、
#実はデータフレームではなくてtibbleというデータフレームが
#強化された形となるのですが、
#最初は「ちょっと便利なデータフレーム」くらいの認識で問題
#ありません。

#col1～col4まで表示されていて<int> <chr>というのは
#その列がどんな型かが表示されています。

#DTというところをクリックしてみてください
#一番下までスクロールすると、
#NAという文字が出てきています。

#実は、自動パースは、デフォルトでは最初の1000行を見て
#判断するという形になっていますが、このファイルは、
#意図的に1010行目から3列目に文字列を、4列目に数字を
#入れてあります。

parse_number(c(1,2,3,4,5,"a","b","c"))

#色々と警告が出ていますが、無視して、結果は、
#>[1]  1  2  3  4  5 NA NA NA

#となっています。これは、数字に変換しようとしたら
#6-8番目のデータが数字に変換できなかったため、
#NA:Not Available; 欠損値として処理されたというものです。

#これと同様の事象が、DTの3列目でも発生しています。
#このような事象を回避するためには、いくつかやり方が
#あります。

#その1：自動的に判断する行数を増やす
#guess_maxというオプションで行を増やすことが
#できます。

#デフォルト
DT <- read_csv("import_practice2.txt", 
               guess_max = c(1000))

tail(DT) #tailは最後の列を表示する関数


#guess_maxを増やす
DT <- read_csv("import_practice2.txt",
               guess_max = c(99999))

tail(DT)
 #col3がきちんと<chr>となり、NAではなくなっています。

#この方法のデメリット：
#  事前に行数がわからない場合は値を何にすればよいかわからない。
#　データによっては処理が重くなることも

#その2:列毎に型を指定してあげる。
DT <- read_csv("import_practice2.txt",
               col_types="iccc")

tail(DT)

#デメリット:
#  事前にどの列にどんなデータが入っているか知っている必要あり
#  それでも、事故的に文字列が数値と思っている列に紛れ込んでいる
#  ケースではNAとなってしまう。

#その3:全部文字列としてとりあえず読み込む
DT <- read_csv("import_practice2.txt",
               col_types=cols(.default="c"))

tail(DT)
#デメリット:
#  後々自分で型変換を必要に応じて行う必要がある

#個人的には、その3の方法を多用して読み込みを行っています。
#列の型変換、Section5のデータ加工を利用すれば、非常に
#簡単にできるので、インポート時点でデータが欠損することを
#避けることを重視しています。

#以上でインポートセクションの説明終了です。次は、
#グラフの描画について説明します。

###########################################################
#レクチャー： 補足：エクセルファイルの読み込み方---------------
###########################################################
#readxl

#.csvや.tsv等は
#データを取り扱う仕事をしているとよく見かけます。
#が、
#一番、頻度が高い形式はExcelファイル(.xls, .xlsx)です。
#残念ながら、readrにはエクセル形式を読み込む
#機能はありませんが、
#readxlパッケージを利用すれば、Excelファイルを
#読み込むことが可能です。

install.packages("readxl")

readxl::read_excel("import_practice.xlsx")













